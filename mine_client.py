from zkp import get_generators, verify_step1, verify_step2
from typing import List, Tuple
from schnorr import Point

class MineClient:
    def __init__(self, n: int, zkp_seed: int):
        self.n = n
        self.g, self.h = get_generators(zkp_seed)
        self.cnt_mines = None
        self.commits = None
        
    def verify_game_creation(self, mine_count: int, cell_commits: List[Point], commit_total_mine: Point, ini_click: Typle[int, int]) -> int:
        """
        Verify initial setup and generate challenge for total mine count proof.
        Returns: challenge for the server
        """
        # Store the commits (will be permuted later)
        self.cnt_mines = mine_count
        self.initial_commits = cell_commits
        self.commit_total_mine = commit_total_mine
        self.ini_click = ini_click
        
        # Generate challenge for total mine count proof
        challenge = verify_step1(self.g)
        return challenge
    
    def verify_total_mine_count(self, challenge: int, response: int) -> bool:
        """
        Verify that the sum of all cells equals cnt_mines.
        """
        sum_commits = sum(self.initial_commits, start=0*self.g)
        
        # Verify the proof that sum equals cnt_mines
        return verify_step2(
            challenge=challenge,
            response=response,
            schnorr_commit=self.commit_total_mine,
            sum_values=self.cnt_mines,
            sum_commits=sum_commits,
            g=self.g,
            h=self.h
        )
    
    def apply_permutation(self, permutation: List[int]) -> None:
        """
        Apply the same permutation to commits as server did.
        """
        # Apply permutation
        from utils import apply_permutation
        permuted = apply_permutation(self.initial_commits, permutation)
        
        # Mark initially dug cells (same logic as server)
        dug_mines = [[False]*self.n for _ in range(self.n)]
        for i in range(max(0, self.ini_click[0]-1), min(self.n, self.ini_click[0]+2)):
            for j in range(max(0, self.ini_click[1]-1), min(self.n, self.ini_click[1]+2)):
                dug_mines[i][j] = True
        
        # Build grid of commits (same logic as server - pop from END)
        self.commits = [[None]*self.n for _ in range(self.n)]
        
        # Server pops from the list, which takes from the end
        # We need to reverse to match server behavior OR pop from end
        for i in range(self.n):
            for j in range(self.n):
                if dug_mines[i][j]:
                    self.commits[i][j] = 0*self.g
                else:
                    self.commits[i][j] = permuted.pop()  # Pop from end, same as server
    
    def verify_dig_mine(self, i: int, j: int, secret: int) -> bool:
        """
        Verify that cell (i,j) contains a mine by checking the commitment.
        Server reveals secret s, client checks: c[i][j] = s*g + 1*h
        """
        expected_commit = secret * self.g + 1 * self.h
        return self.commits[i][j] == expected_commit
    
    def verify_dig_safe(self, i: int, j: int, mine_count: int, proof_commit: Point, 
                       challenge: int, response: int) -> bool:
        """
        Verify that the neighboring cells sum to mine_count.
        
        Args:
            i, j: Cell coordinates
            mine_count: Number of mines in neighboring cells (what server claims)
            proof_commit: Schnorr commitment from prove_step1
            challenge: Challenge generated by client
            response: Response from server's prove_step2
        """
        # Collect commits of neighboring cells
        neighbor_commits = []
        for ni in range(max(i-1, 0), min(i+2, self.n)):
            for nj in range(max(j-1, 0), min(j+2, self.n)):
                neighbor_commits.append(self.commits[ni][nj])
        
        sum_commits = sum(neighbor_commits, start=0*self.g)
        
        # Verify the proof
        return verify_step2(
            challenge=challenge,
            response=response,
            schnorr_commit=proof_commit,
            sum_values=mine_count,
            sum_commits=sum_commits,
            g=self.g,
            h=self.h
        )
    
    def generate_challenge(self) -> int:
        """Generate a random challenge for the server."""
        return verify_step1(self.g)